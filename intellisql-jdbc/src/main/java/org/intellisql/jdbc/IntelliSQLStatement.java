/*
 * Licensed to the IntelliSQL Project under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The IntelliSQL Project licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.intellisql.jdbc;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;

import org.apache.calcite.avatica.Meta;
import org.apache.calcite.avatica.remote.Service;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

/** JDBC Statement implementation for IntelliSql. */
@Slf4j
@Getter
public class IntelliSqlStatement implements Statement {

    private static final String STMT_CLOSED = "Statement is closed";

    // CHECKSTYLE:OFF: VisibilityModifier
    // Protected fields needed for subclass access in IntelliSqlPreparedStatement
    protected final IntelliSqlConnection connection;

    protected final int statementId;

    protected boolean closed;

    protected ResultSet currentResultSet;

    protected long updateCount = -1;

    protected int fetchSize;

    protected int queryTimeout;

    protected int maxRows;

    protected SQLWarning warningChain;

    protected Meta.StatementHandle statementHandle;
    // CHECKSTYLE:ON: VisibilityModifier

    /**
     * Creates a new statement.
     *
     * @param connection the parent connection
     * @param statementId the statement ID
     */
    public IntelliSqlStatement(final IntelliSqlConnection connection, final int statementId) {
        this.connection = connection;
        this.statementId = statementId;
        this.fetchSize = connection.getIntProperty("fetchSize", 1000);
        this.queryTimeout = connection.getIntProperty("queryTimeout", 300);
        this.maxRows = (int) connection.getLongProperty("maxRows", 0);
        log.debug("Created statement: {}", statementId);
    }

    @Override
    public ResultSet executeQuery(final String sql) throws SQLException {
        checkClosed();
        closeCurrentResultSet();
        Service.PrepareResponse prepareResponse =
                connection.getClient().prepare(connection.getConnectionId(), sql, maxRows);
        statementHandle = prepareResponse.statement;
        Service.ExecuteResponse executeResponse =
                connection.getClient().execute(statementHandle, null, fetchSize);
        currentResultSet = createResultSet(statementHandle, executeResponse);
        updateCount = -1;
        return currentResultSet;
    }

    protected IntelliSqlResultSet createResultSet(
                                                  final Meta.StatementHandle handle, final Service.ExecuteResponse response) {
        Meta.Signature signature = null;
        Meta.Frame firstFrame = null;
        if (response != null && response.results != null && !response.results.isEmpty()) {
            Service.ResultSetResponse result = response.results.get(0);
            if (result.signature != null) {
                signature = result.signature;
            }
            if (result.firstFrame != null) {
                firstFrame = result.firstFrame;
            }
        }
        return new IntelliSqlResultSet(this, handle, signature, firstFrame);
    }

    @Override
    public int executeUpdate(final String sql) throws SQLException {
        checkClosed();
        closeCurrentResultSet();
        Service.PrepareResponse prepareResponse =
                connection.getClient().prepare(connection.getConnectionId(), sql, maxRows);
        connection.getClient().execute(prepareResponse.statement, null, fetchSize);
        updateCount = 0;
        currentResultSet = null;
        return (int) updateCount;
    }

    @Override
    public int executeUpdate(final String sql, final int autoGeneratedKeys) throws SQLException {
        return executeUpdate(sql);
    }

    @Override
    public int executeUpdate(final String sql, final int[] columnIndexes) throws SQLException {
        return executeUpdate(sql);
    }

    @Override
    public int executeUpdate(final String sql, final String[] columnNames) throws SQLException {
        return executeUpdate(sql);
    }

    @Override
    public void close() throws SQLException {
        if (closed) {
            return;
        }
        try {
            closeCurrentResultSet();
            connection.getClient().closeStatement(connection.getConnectionId(), statementId);
            log.debug("Closed statement: {}", statementId);
            // CHECKSTYLE:OFF: IllegalCatch
        } catch (final Exception ex) {
            // CHECKSTYLE:ON: IllegalCatch
            log.warn("Error closing statement", ex);
        } finally {
            closed = true;
        }
    }

    @Override
    public boolean isClosed() throws SQLException {
        return closed;
    }

    @Override
    public int getMaxFieldSize() throws SQLException {
        checkClosed();
        return 0;
    }

    @Override
    public void setMaxFieldSize(final int max) throws SQLException {
        checkClosed();
    }

    @Override
    public int getMaxRows() throws SQLException {
        checkClosed();
        return maxRows;
    }

    @Override
    public void setMaxRows(final int max) throws SQLException {
        checkClosed();
        if (max < 0) {
            throw new SQLException("Max rows must be >= 0");
        }
        this.maxRows = max;
    }

    @Override
    public void setEscapeProcessing(final boolean enable) throws SQLException {
        checkClosed();
    }

    @Override
    public int getQueryTimeout() throws SQLException {
        checkClosed();
        return queryTimeout;
    }

    @Override
    public void setQueryTimeout(final int seconds) throws SQLException {
        checkClosed();
        if (seconds < 0) {
            throw new SQLException("Query timeout must be >= 0");
        }
        this.queryTimeout = seconds;
    }

    @Override
    public void cancel() throws SQLException {
        checkClosed();
    }

    @Override
    public SQLWarning getWarnings() throws SQLException {
        checkClosed();
        return warningChain;
    }

    @Override
    public void clearWarnings() throws SQLException {
        checkClosed();
        warningChain = null;
    }

    @Override
    public void setCursorName(final String name) throws SQLException {
        checkClosed();
    }

    @Override
    public boolean execute(final String sql) throws SQLException {
        checkClosed();
        closeCurrentResultSet();
        Service.PrepareResponse prepareResponse =
                connection.getClient().prepare(connection.getConnectionId(), sql, maxRows);
        Service.ExecuteResponse executeResponse =
                connection.getClient().execute(prepareResponse.statement, null, fetchSize);
        currentResultSet = createResultSet(prepareResponse.statement, executeResponse);
        updateCount = -1;
        return true;
    }

    @Override
    public boolean execute(final String sql, final int autoGeneratedKeys) throws SQLException {
        return execute(sql);
    }

    @Override
    public boolean execute(final String sql, final int[] columnIndexes) throws SQLException {
        return execute(sql);
    }

    @Override
    public boolean execute(final String sql, final String[] columnNames) throws SQLException {
        return execute(sql);
    }

    @Override
    public ResultSet getResultSet() throws SQLException {
        checkClosed();
        return currentResultSet;
    }

    @Override
    public int getUpdateCount() throws SQLException {
        checkClosed();
        return (int) updateCount;
    }

    @Override
    public boolean getMoreResults() throws SQLException {
        checkClosed();
        closeCurrentResultSet();
        updateCount = -1;
        return false;
    }

    @Override
    public boolean getMoreResults(final int current) throws SQLException {
        checkClosed();
        closeCurrentResultSet();
        updateCount = -1;
        return false;
    }

    @Override
    public void setFetchDirection(final int direction) throws SQLException {
        checkClosed();
        if (direction != ResultSet.FETCH_FORWARD) {
            throw new SQLException("Only FETCH_FORWARD is supported");
        }
    }

    @Override
    public int getFetchDirection() throws SQLException {
        checkClosed();
        return ResultSet.FETCH_FORWARD;
    }

    @Override
    public void setFetchSize(final int rows) throws SQLException {
        checkClosed();
        if (rows < 0) {
            throw new SQLException("Fetch size must be >= 0");
        }
        this.fetchSize = rows > 0 ? rows : 1000;
    }

    @Override
    public int getFetchSize() throws SQLException {
        checkClosed();
        return fetchSize;
    }

    @Override
    public int getResultSetConcurrency() throws SQLException {
        checkClosed();
        return ResultSet.CONCUR_READ_ONLY;
    }

    @Override
    public int getResultSetType() throws SQLException {
        checkClosed();
        return ResultSet.TYPE_FORWARD_ONLY;
    }

    @Override
    public void addBatch(final String sql) throws SQLException {
        checkClosed();
        throw new SQLException("Batch updates not supported in MVP");
    }

    @Override
    public void clearBatch() throws SQLException {
        checkClosed();
        throw new SQLException("Batch updates not supported in MVP");
    }

    @Override
    public int[] executeBatch() throws SQLException {
        checkClosed();
        throw new SQLException("Batch updates not supported in MVP");
    }

    @Override
    public Connection getConnection() throws SQLException {
        checkClosed();
        return connection;
    }

    @Override
    public ResultSet getGeneratedKeys() throws SQLException {
        checkClosed();
        throw new SQLException("Generated keys not supported in MVP");
    }

    @Override
    public int getResultSetHoldability() throws SQLException {
        checkClosed();
        return ResultSet.HOLD_CURSORS_OVER_COMMIT;
    }

    @Override
    public boolean isPoolable() throws SQLException {
        checkClosed();
        return false;
    }

    @Override
    public void setPoolable(final boolean poolable) throws SQLException {
        checkClosed();
    }

    @Override
    public void closeOnCompletion() throws SQLException {
        checkClosed();
    }

    @Override
    public boolean isCloseOnCompletion() throws SQLException {
        checkClosed();
        return false;
    }

    @Override
    public <T> T unwrap(final Class<T> iface) throws SQLException {
        if (iface.isInstance(this)) {
            return iface.cast(this);
        }
        throw new SQLException("Not a wrapper for " + iface.getName());
    }

    @Override
    public boolean isWrapperFor(final Class<?> iface) throws SQLException {
        return iface.isInstance(this);
    }

    void addWarning(final SQLWarning warning) {
        if (warningChain == null) {
            warningChain = warning;
        } else {
            warningChain.setNextWarning(warning);
        }
    }

    protected void checkClosed() throws SQLException {
        if (closed) {
            throw new SQLException(STMT_CLOSED);
        }
    }

    protected void closeCurrentResultSet() throws SQLException {
        if (currentResultSet != null) {
            try {
                currentResultSet.close();
                // CHECKSTYLE:OFF: IllegalCatch
            } catch (final Exception ex) {
                // CHECKSTYLE:ON: IllegalCatch
                log.warn("Error closing result set", ex);
            } finally {
                currentResultSet = null;
            }
        }
    }
}
